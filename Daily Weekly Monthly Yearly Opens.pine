// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© sbtnc
// Created: 2020-01-11
// Last modified: 2024-11-19
// version 6.0

// @version=5
indicator("Daily Weekly Monthly Yearly Opens", "DWMY O", true, max_lines_count=500)


//--------------------------------------------------------------------
//#region                      Constants
//--------------------------------------------------------------------

int     HEAD_PADDING    = -2
int     HEAD_TRANSP     = 60
string  LABEL_SIZE      = size.small
string  LABEL_STYLE     = label.style_none
string  LINE_STYLE      = line.style_solid
int     LINE_WIDTH      = 1
int     OFFSET_PADDING  = 4
string  TAIL_STYLE      = line.style_dotted
color   COLOR_1         = color.green
color   COLOR_2         = color.orange
color   COLOR_3         = color.red
color   COLOR_4         = color.blue

//#endregion


//--------------------------------------------------------------------
//#region                        Inputs
//--------------------------------------------------------------------

string  g1 = "Opens"
string  g2 = "Style"
string  g3 = "Preferences"

string  tailsTooltip            = "Extends last opens on historical bars."
string  headsTooltip            = "Extends previous opens in the future."
string  discoverPricesTooltip   = "Discovers the opening prices from the intraday chart.\n\nYou may use this setting when there are discrepancies between the data from intraday and high time frames."
string  extendedHoursTooltip    = "Discovers the opening prices from the extended trading hours if available."

bool    enableOpenInput1        = input.bool        (true,      title = "", group = g1, inline = "#1")
string  openTimeframeInput1     = input.timeframe   ("D",       title = "", group = g1, inline = "#1")
color   openColorInput1         = input.color       (COLOR_1,   title = "", group = g1, inline = "#1")
int     openLookbackInput1      = input.int         (1,         title = "", group = g1, inline = "#1", minval = 1)

bool    enableOpenInput2        = input.bool        (true,      title = "", group = g1, inline = "#2")
string  openTimeframeInput2     = input.timeframe   ("W",       title = "", group = g1, inline = "#2")
color   openColorInput2         = input.color       (COLOR_2,   title = "", group = g1, inline = "#2")
int     openLookbackInput2      = input.int         (1,         title = "", group = g1, inline = "#2", minval = 1)

bool    enableOpenInput3        = input.bool        (true,      title = "", group = g1, inline = "#3")
string  openTimeframeInput3     = input.timeframe   ("M",       title = "", group = g1, inline = "#3")
color   openColorInput3         = input.color       (COLOR_3,   title = "", group = g1, inline = "#3")
int     openLookbackInput3      = input.int         (1,         title = "", group = g1, inline = "#3", minval = 1)

bool    enableOpenInput4        = input.bool        (true,      title = "", group = g1, inline = "#4")
string  openTimeframeInput4     = input.timeframe   ("12M",     title = "", group = g1, inline = "#4")
color   openColorInput4         = input.color       (COLOR_4,   title = "", group = g1, inline = "#4")
int     openLookbackInput4      = input.int         (1,         title = "", group = g1, inline = "#4", minval = 1)

int     rightOffsetInput        = input.int         (20,        title = "Offset",           group = g2, minval = 1)
bool    areTailsEnabledInput    = input.bool        (false,     title = "Show Tails",       group = g2, tooltip = tailsTooltip)
bool    areHeadsEnabledInput    = input.bool        (false,     title = "Show Projections", group = g2, tooltip = headsTooltip)
bool    discoverPricesInput     = input.bool        (false,     title = "Discover Prices",  group = g3, tooltip = discoverPricesTooltip)
bool    extendedHoursInput      = input.bool        (false,     title = "Extended Hours",   group = g3, tooltip = extendedHoursTooltip)

//#endregion


//--------------------------------------------------------------------
//#region                   Functions & methods
//--------------------------------------------------------------------

// @function Check if the specified open `timeframe` can be displayed on the chart context.
// @returns  simple bool
method isVisible(simple string timeframe) =>
    timeframe.in_seconds(timeframe) > timeframe.in_seconds()

//#endregion



//--------------------------------------------------------------------
//#region                 Variables declarations
//--------------------------------------------------------------------

var array<float> lastOpenArray  = array.new_float(4)
var bool hasExtendedHours       = extendedHoursInput and syminfo.session == session.extended
var bool discoverPrices         = discoverPricesInput or hasExtendedHours

// @variable Is true if the display setting is enabled and chart timeframe is lower than the open's one.
var bool displayOpen1 = enableOpenInput1 and openTimeframeInput1.isVisible()
var bool displayOpen2 = enableOpenInput2 and openTimeframeInput2.isVisible()
var bool displayOpen3 = enableOpenInput3 and openTimeframeInput3.isVisible()
var bool displayOpen4 = enableOpenInput4 and openTimeframeInput4.isVisible()

[time1, open1] = request.security("", openTimeframeInput1, [time, open], lookahead=barmerge.lookahead_on)
[time2, open2] = request.security("", openTimeframeInput2, [time, open], lookahead=barmerge.lookahead_on)
[time3, open3] = request.security("", openTimeframeInput3, [time, open], lookahead=barmerge.lookahead_on)
[time4, open4] = request.security("", openTimeframeInput4, [time, open], lookahead=barmerge.lookahead_on)

//#endregion


//--------------------------------------------------------------------
//#region                   Functions & methods
//--------------------------------------------------------------------

// If different opens share the same opening prices, their labels will overlap
// Instead, we pad the higher time frame ones for achieving a "separator sheet"
f_getPadding(int _index) =>
    _padding = 0
    // Weekly, monthly, or yearly overlaps the daily open
    if _index > 0 and displayOpen1 and array.get(lastOpenArray, 0) == array.get(lastOpenArray, _index)
        _padding += 1
    // Monthly or yearly overlaps the weekly open
    if _index > 1 and displayOpen2 and array.get(lastOpenArray, 1) == array.get(lastOpenArray, _index)
        _padding += 1
    // Yearly overlaps the monthly open
    if _index > 2 and displayOpen3 and array.get(lastOpenArray, 2) == array.get(lastOpenArray, _index)
        _padding += 1
    _padding

f_getRightBarIndex(int _padding) => bar_index + rightOffsetInput + _padding * OFFSET_PADDING

// On the weekly time frame, the monthly/yearly open is drawn from the first candle of the month/year
// The first weekly candle is not necessarily containing the first day of the month
// In such case, we visually anchor the open of the previous weekly candle
f_isContainedOnPrevWeekly(int _time) => timeframe.isweekly and dayofmonth(time) > dayofmonth(_time)

// Compare previous value and new value
// When the argument series contains `na` don't resolve `na` (returns true on the first bar's comparaison)
f_hasChanged(_series) => not (_series == _series[1])

// Create and update an open level. An open is composed of a label, a "body" line, and optional "tail" and "head" lines extensions
f_draw(bool _newOpen, float _y, int _lookback, int _padding, color _color, string _text, bool _prevTime=false) =>
    var line _body  = na 
    var _label      = label.new(na, na, _text, style=LABEL_STYLE, textcolor=_color, size=LABEL_SIZE)
    var _tail       = line.new(na, na, na, na, color=_color, style=TAIL_STYLE, width=LINE_WIDTH, extend=extend.left)
    var _bodies     = array.new_line()
    var _heads      = array.new_line()
    _start          = _prevTime ? bar_index - 1 : bar_index
    _end            = f_getRightBarIndex(_padding)

    if _newOpen
        // Label
        label.set_xy(_label, _end, _y)
        label.set_tooltip(_label, str.tostring(_y, format.mintick))

        // Body
        line.set_x2(_body, bar_index)
        _body := line.new(_start, _y, _end, _y, color=_color, style=LINE_STYLE, width=LINE_WIDTH)
        array.push(_bodies, _body)

        // Head
        if areHeadsEnabledInput
            array.push(_heads, line.new(bar_index, _y, bar_index, _y, color=color.new(_color, HEAD_TRANSP), style=LINE_STYLE, width=LINE_WIDTH))

        // Tail
        if areTailsEnabledInput
            line.set_xy1(_tail, _start - 1, _y)
            line.set_xy2(_tail, _start, _y)

        if array.size(_bodies) > _lookback
            line.delete(array.shift(_bodies))
        if array.size(_heads) > _lookback
            line.delete(array.shift(_heads))

    if barstate.islast
        line.set_x2(_body, _end)
        label.set_x(_label, _end)

        if areHeadsEnabledInput and array.size(_heads) > 1
            // Not updating the last open's projection
            for i = 0 to array.size(_heads) - 2
                // Avoid projecting on last opens bodies
                if not array.includes(lastOpenArray, line.get_y1(array.get(_heads, i)))
                    line.set_x2(array.get(_heads, i), f_getRightBarIndex(HEAD_PADDING))

//#endregion


//--------------------------------------------------------------------
//#region                         Logic
//--------------------------------------------------------------------

bool hastime1Changed        = hasExtendedHours ? ta.change(time_tradingday) : discoverPrices ? f_hasChanged(time1) and time == time1        : f_hasChanged(time1)
bool hasWeekklyTimeChanged  = hasExtendedHours ? ta.change(weekofyear)      : discoverPrices ? f_hasChanged(time2) and time == time2      : f_hasChanged(time2)
bool hastime3Changed        = hasExtendedHours ? ta.change(month)           : discoverPrices ? f_hasChanged(time3) and time == time3    : f_hasChanged(time3)
bool hastime4Changed        = hasExtendedHours ? ta.change(year)            : discoverPrices ? f_hasChanged(time4) and time == time4      : f_hasChanged(time4)

if displayOpen1 and hastime1Changed 
    array.set(lastOpenArray, 0, discoverPrices ? open : open1)

if displayOpen2 and hasWeekklyTimeChanged
    array.set(lastOpenArray, 1, discoverPrices ? open : open2)

if displayOpen3 and hastime3Changed
    array.set(lastOpenArray, 2, discoverPrices ? open : open3)

if displayOpen4 and hastime4Changed
    array.set(lastOpenArray, 3, discoverPrices ? open : open4)

//#endregion


//--------------------------------------------------------------------
//#region                        Visuals
//--------------------------------------------------------------------

if displayOpen4
    f_draw(hastime4Changed, array.get(lastOpenArray, 3), openLookbackInput4, f_getPadding(3), openColorInput4, "Y   ", f_isContainedOnPrevWeekly(time4))

if displayOpen3
    f_draw(hastime3Changed, array.get(lastOpenArray, 2), openLookbackInput3, f_getPadding(2), openColorInput3, "M   ", f_isContainedOnPrevWeekly(time3))

if displayOpen2
    f_draw(hasWeekklyTimeChanged, array.get(lastOpenArray, 1), openLookbackInput2, f_getPadding(1), openColorInput2, "W   ")

if displayOpen1
    f_draw(hastime1Changed, array.get(lastOpenArray, 0), openLookbackInput1, f_getPadding(0), openColorInput1, "D   ")

// Plot invisible opens for displaying last values in `status line`, `scale`, `data window` as well for providing defaults alert conditions

plot(array.get(lastOpenArray, 0), "D",    color.new(openColorInput1, 100),   editable=false)
plot(array.get(lastOpenArray, 1), "W",    color.new(openColorInput2, 100),  editable=false)
plot(array.get(lastOpenArray, 2), "M",    color.new(openColorInput3, 100), editable=false)
plot(array.get(lastOpenArray, 3), "Y",    color.new(openColorInput4, 100),  editable=false)

//#endregion