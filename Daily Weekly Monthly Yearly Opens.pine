// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© sbtnc
// Created: 2020-01-11
// Last modified: 2024-11-20
// version 6.0

// @version=5
indicator("Daily Weekly Monthly Yearly Opens", "Opens", overlay = true, max_lines_count = 500)


//--------------------------------------------------------------------
//#region                      Constants
//--------------------------------------------------------------------

int     HEAD_PADDING    = -2
int     HEAD_TRANSP     = 60
string  LABEL_SIZE      = size.small
string  LABEL_STYLE     = label.style_none
string  LINE_STYLE      = line.style_solid
int     LINE_WIDTH      = 1
int     OFFSET_PADDING  = 4
string  TAIL_STYLE      = line.style_dotted
color   COLOR_1         = color.green
color   COLOR_2         = color.orange
color   COLOR_3         = color.red
color   COLOR_4         = color.blue

//#endregion


//--------------------------------------------------------------------
//#region                         Types 
//--------------------------------------------------------------------

// @enum Contains fields with the indicator configurable timeframes as titles.
enum Timeframes
    s5  = "5 seconds"
    s10 = "10 seconds"
    s15 = "15 seconds"
    s30 = "30 seconds"
    m1  = "1 minute"
    m2  = "2 minutes"
    m3  = "3 minutes"
    m5  = "5 minutes"
    m10 = "10 minutes"
    m15 = "15 minutes"
    m30 = "30 minutes"
    m45 = "45 minutes"
    h1  = "1 hour"
    h2  = "2 hours"
    h3  = "3 hours"
    h4  = "4 hours"
    h6  = "6 hours"
    h8  = "8 hours"
    h12 = "12 hours"
    D1  = "1 day"
    W1  = "1 week"
    M1  = "1 month"
    M3  = "3 months"
    M6  = "6 months"
    M12 = "12 months"

//#endregion


//--------------------------------------------------------------------
//#region                        Inputs
//--------------------------------------------------------------------

string      g1                          = "Opens"
string      g2                          = "Style"
string      g3                          = "Preferences"

string      tailsTooltip                = "Extends last opens on historical bars."
string      headsTooltip                = "Extends previous opens in the future."
string      discoverPricesTooltip       = "Discovers the opening prices from the intraday chart.\n\nYou may use this setting when there are discrepancies between the data from intraday and high time frames."
string      extendedHoursTooltip        = "Display the opening prices on the extended trading hours if visible."

bool        enableOpenInput1            = input.bool        (true,              title = "", group = g1, inline = "#1")
Timeframes  openTimeframeInput1         = input.enum        (Timeframes.D1,     title = "", group = g1, inline = "#1", display = display.none)
color       openColorInput1             = input.color       (COLOR_1,           title = "", group = g1, inline = "#1")
int         openLookbackInput1          = input.int         (1,                 title = "", group = g1, inline = "#1", minval = 1, display = display.none)

bool        enableOpenInput2            = input.bool        (true,              title = "", group = g1, inline = "#2")
Timeframes  openTimeframeInput2         = input.enum        (Timeframes.W1,     title = "", group = g1, inline = "#2", display = display.none)
color       openColorInput2             = input.color       (COLOR_2,           title = "", group = g1, inline = "#2")
int         openLookbackInput2          = input.int         (1,                 title = "", group = g1, inline = "#2", minval = 1, display = display.none)

bool        enableOpenInput3            = input.bool        (true,              title = "", group = g1, inline = "#3")
Timeframes  openTimeframeInput3         = input.enum        (Timeframes.M1,     title = "", group = g1, inline = "#3", display = display.none)
color       openColorInput3             = input.color       (COLOR_3,           title = "", group = g1, inline = "#3")
int         openLookbackInput3          = input.int         (1,                 title = "", group = g1, inline = "#3", minval = 1, display = display.none)

bool        enableOpenInput4            = input.bool        (true,              title = "", group = g1, inline = "#4")
Timeframes  openTimeframeInput4         = input.enum        (Timeframes.M12,    title = "", group = g1, inline = "#4", display = display.none)
color       openColorInput4             = input.color       (COLOR_4,           title = "", group = g1, inline = "#4")
int         openLookbackInput4          = input.int         (1,                 title = "", group = g1, inline = "#4", minval = 1, display = display.none)

int         rightOffsetInput            = input.int         (20,                title = "Offset",           group = g2, minval = 1, display = display.none)
bool        enableTailsInput            = input.bool        (false,             title = "Show Tails",       group = g2, tooltip = tailsTooltip)
bool        enableHeadsInput            = input.bool        (false,             title = "Show Projections", group = g2, tooltip = headsTooltip)
bool        discoverPricesInput         = input.bool        (false,             title = "Discover Prices",  group = g3, tooltip = discoverPricesTooltip)
bool        enableExtendedSessionInput  = input.bool        (false,             title = "Extended Hours",   group = g3, tooltip = extendedHoursTooltip)

//#endregion


//--------------------------------------------------------------------
//#region                   Functions & methods
//--------------------------------------------------------------------

// @function Check if the specified open `timeframe` can be displayed on the chart context.
// @returns  simple bool
method isVisible(simple string timeframe) =>
    timeframe.in_seconds(timeframe) > timeframe.in_seconds()


// @function Check if the specified open change.
// @returns  series bool
method change(simple string timeframe, series int regularTime, simple bool enableExtended) =>
    switch enableExtended
        true  => timeframe.change(timeframe)
        false => ta.change(regularTime) > 0


// @function 
// @returns  
method request(string timeframe, bool useExtendedTradingHours) =>
    string tickerId = ticker.new(syminfo.prefix, syminfo.ticker, useExtendedTradingHours ? session.extended : session.regular)
    request.security(tickerId, timeframe, [time, open], lookahead = barmerge.lookahead_on)


// @function 
// @returns  
// On the weekly time frame, the monthly/yearly open is drawn from the first candle of the month/year
// The first weekly candle is not necessarily containing the first day of the month
// In such case, we visually anchor the open of the previous weekly candle
f_isContainedOnPrevWeekly(int _time) =>
    // timeframe.isweekly and dayofmonth(time) > dayofmonth(_time)
    time_close[1] > _time
    //false 


// @function 
// @returns  
f_getRightBarIndex(int _padding) => bar_index + rightOffsetInput + _padding * OFFSET_PADDING


// @function Produce the `timeframe` parameter from the given user input.
// @returns  string
method param(simple Timeframes input) =>
    switch input
        Timeframes.s5  => "5S"
        Timeframes.s10 => "10S"
        Timeframes.s15 => "15S"
        Timeframes.s30 => "30S"
        Timeframes.m1  => "1"
        Timeframes.m2  => "2"
        Timeframes.m3  => "3"
        Timeframes.m5  => "5"
        Timeframes.m10 => "10"
        Timeframes.m15 => "15"
        Timeframes.m30 => "30"
        Timeframes.m45 => "45"
        Timeframes.h1  => "60"
        Timeframes.h2  => "120"
        Timeframes.h3  => "180"
        Timeframes.h4  => "240"
        Timeframes.h6  => "360"
        Timeframes.h8  => "480"
        Timeframes.h12 => "720"
        Timeframes.D1  => "1D"
        Timeframes.W1  => "1W"
        Timeframes.M1  => "1M" 
        Timeframes.M3  => "3M"
        Timeframes.M6  => "6M"
        Timeframes.M12 => "12M"


// @function Return the short display string for minutes and hours `timeframe` string
// @returns  string
method displayString(string this) =>
    // Format
    _str = switch this
        "1"     => "m"
        "2"     => "2m"
        "3"     => "3m"
        "5"     => "5m"
        "10"    => "10m"
        "15"    => "15m"
        "30"    => "30m"
        "45"    => "45m"
        "60"    => "H"
        "120"   => "2H"
        "180"   => "3H"
        "240"   => "4H"
        "360"   => "6H"
        "480"   => "8H"
        "720"   => "12H"
        "1440"  => "24H"
        "1D"    => "D"
        "1W"    => "W"
        "1M"    => "M"
        "12M"   => "Y"
        => this

    // Add spacing
    switch str.length(_str)
        1 => _str + "   "
        2 => _str + "     "
        3 => _str + "       "


// @function Create and update an open level. An open is composed of a label, a "body" line, and optional "tail" and "head" lines extensions.
// @returns  void
draw(bool change, float y, int lookback, int padding, color color, string txt, array<float> lastOpenArray, bool prevTime = false) =>
    // @variable The reference of the last open line.
    var line _bodyLine = na
    // @variable The reference of the last open label.
    var label _label = label.new(x = na, y = na, text = txt, style = LABEL_STYLE, textcolor = color, size = LABEL_SIZE)
    // @variable The reference of the last open left extending line.
    var line _tailLine = line.new(x1 = na, y1 = na, x2 = na, y2 = na, color = color, style = TAIL_STYLE, width = LINE_WIDTH, extend = extend.left)
    // @variable The collection of historical open lines.
    var array<line> _bodyLineArray  = array.new_line()
    // @variable The collection of historical right extending open lines.
    var array<line> _headLineArray  = array.new_line()

    int _startBarIndex  = prevTime ? bar_index - 1 : bar_index
    int _endBarIndex    = f_getRightBarIndex(padding)

    if change
        // Anchor the old open position.
        _bodyLine.set_x2(prevTime ? bar_index - 1 : bar_index)

        // Update the last open label position and tooltip.
        _label.set_xy(_endBarIndex, y)
        _label.set_tooltip(str.tostring(y, format.mintick))

        // Create the last open line.
        _bodyLine := line.new(x1 = _startBarIndex, y1 = y, x2 = _endBarIndex, y2 = y, color = color, style = LINE_STYLE, width = LINE_WIDTH)
        array.push(_bodyLineArray, _bodyLine)

        // Create the last open right extension.
        if enableHeadsInput
            _headLineArray.push(line.new(x1 = bar_index, y1 = y, x2 = bar_index, y2 = y, color = color.new(color, HEAD_TRANSP), style = LINE_STYLE, width = LINE_WIDTH))

        // Create the last open left extension.
        if enableTailsInput
            _tailLine.set_xy1(_startBarIndex -1, y)
            _tailLine.set_xy2(_startBarIndex,    y)

        // Trim the exceeding number of drawings.
        if _bodyLineArray.size() > lookback
            line.delete(_bodyLineArray.shift())
        if _headLineArray.size() > lookback
            line.delete(_headLineArray.shift())

    if barstate.islast
        _bodyLine.set_x2(_endBarIndex)
        _label.set_x(_endBarIndex)

        if enableHeadsInput and _headLineArray.size() > 1
            // Not updating the last open's projection
            for i = 0 to _headLineArray.size() - 2
                // Avoid projecting on last opens bodies
                if not lastOpenArray.includes(_headLineArray.get(i).get_y1())
                    _headLineArray.get(i).set_x2(f_getRightBarIndex(HEAD_PADDING))


// @function 
// @returns 
// If different opens share the same opening prices, their labels will overlap
// Instead, we pad the higher time frame ones for achieving a "separator sheet"
f_getPadding(int _index, bool displayOpen1, bool displayOpen2, bool displayOpen3, array<float> lastOpenArray) =>
    _padding = 0
    // Weekly, monthly, or yearly overlaps the daily open
    if _index > 0 and displayOpen1 and array.get(lastOpenArray, 0) == array.get(lastOpenArray, _index)
        _padding += 1
    // Monthly or yearly overlaps the weekly open
    if _index > 1 and displayOpen2 and array.get(lastOpenArray, 1) == array.get(lastOpenArray, _index)
        _padding += 1
    // Yearly overlaps the monthly open
    if _index > 2 and displayOpen3 and array.get(lastOpenArray, 2) == array.get(lastOpenArray, _index)
        _padding += 1
    _padding

//#endregion



//--------------------------------------------------------------------
//#region                 Variables declarations
//--------------------------------------------------------------------

// @variable
var array<float> lastOpenArray = array.new_float(4)


// @variable True if using the open price of the extended session.
var bool useExtendedTradingHours = enableExtendedSessionInput and syminfo.session == session.extended


// @variable True if the open price is sourced from the chart context.
// Discover only if timeframe >= D ?
discoverPrice(timeframe) =>
    discoverPricesInput or (useExtendedTradingHours and timeframe.in_seconds(timeframe) >= timeframe.in_seconds("D"))


// @variable The `timeframe` parameters produced from the user inputs.
var string openTimeframe1 = openTimeframeInput1.param()
var string openTimeframe2 = openTimeframeInput2.param()
var string openTimeframe3 = openTimeframeInput3.param()
var string openTimeframe4 = openTimeframeInput4.param()


// @variable Is true if the display setting is enabled and chart timeframe is lower than the open's one.
var bool displayOpen1 = enableOpenInput1 and openTimeframe1.isVisible()
var bool displayOpen2 = enableOpenInput2 and openTimeframe2.isVisible()
var bool displayOpen3 = enableOpenInput3 and openTimeframe3.isVisible()
var bool displayOpen4 = enableOpenInput4 and openTimeframe4.isVisible()


// @variable The opening time and price sourced from the user-selected timeframe context.
[time1, open1] = openTimeframe1.request(useExtendedTradingHours)
[time2, open2] = openTimeframe2.request(useExtendedTradingHours)
[time3, open3] = openTimeframe3.request(useExtendedTradingHours)
[time4, open4] = openTimeframe4.request(useExtendedTradingHours)

//#endregion


//--------------------------------------------------------------------
//#region                         Logic
//--------------------------------------------------------------------

bool openChange1 = openTimeframe1.change(time1, useExtendedTradingHours)
bool openChange2 = openTimeframe2.change(time2, useExtendedTradingHours)
bool openChange3 = openTimeframe3.change(time3, useExtendedTradingHours)
bool openChange4 = openTimeframe4.change(time4, useExtendedTradingHours)


if displayOpen1 and openChange1
    bool _discovery = discoverPrice(openTimeframe1)
    lastOpenArray.set(0, _discovery ? open : open1)

if displayOpen2 and openChange2
    bool _discovery = discoverPrice(openTimeframe2)
    lastOpenArray.set(1, _discovery ? open : open2)

if displayOpen3 and openChange3
    bool _discovery = discoverPrice(openTimeframe3)
    lastOpenArray.set(2, _discovery ? open : open3)

if displayOpen4 and openChange4
    bool _discovery = discoverPrice(openTimeframe4)
    lastOpenArray.set(3, _discovery ? open : open4)

//#endregion


//--------------------------------------------------------------------
//#region                        Visuals
//--------------------------------------------------------------------

if displayOpen4
    draw(
         openChange4,
         array.get(lastOpenArray, 3),
         openLookbackInput4,
         f_getPadding(3, displayOpen1, displayOpen2, displayOpen3, lastOpenArray),
         openColorInput4,
         openTimeframe4.displayString(),
         lastOpenArray,
         f_isContainedOnPrevWeekly(time4)
         )

if displayOpen3
    draw(
         openChange3,
         array.get(lastOpenArray, 2),
         openLookbackInput3,
         f_getPadding(2, displayOpen1, displayOpen2, displayOpen3, lastOpenArray),
         openColorInput3,
         openTimeframe3.displayString(),
         lastOpenArray,
         f_isContainedOnPrevWeekly(time3)
         )

if displayOpen2
    draw(
         openChange2,
         array.get(lastOpenArray, 1),
         openLookbackInput2,
         f_getPadding(1, displayOpen1, displayOpen2, displayOpen3, lastOpenArray),
         openColorInput2,
         openTimeframe2.displayString(),
         lastOpenArray,
         f_isContainedOnPrevWeekly(time2)
         )

if displayOpen1
    draw(
         openChange1,
         array.get(lastOpenArray, 0),
         openLookbackInput1,
         f_getPadding(0, displayOpen1, displayOpen2, displayOpen3, lastOpenArray),
         openColorInput1,
         openTimeframe1.displayString(),
         lastOpenArray,
         f_isContainedOnPrevWeekly(time1)
         )


// Plot the open prices on the `status line`, `scale`, `data window` as well for providing default alert conditions.

displayControls = display.status_line + display.price_scale + display.data_window

plot(series = lastOpenArray.get(0), title = "#1", color = COLOR_1, editable = false, display = displayControls)
plot(series = lastOpenArray.get(1), title = "#2", color = COLOR_2, editable = false, display = displayControls)
plot(series = lastOpenArray.get(2), title = "#3", color = COLOR_3, editable = false, display = displayControls)
plot(series = lastOpenArray.get(3), title = "#4", color = COLOR_4, editable = false, display = displayControls)

//#endregion